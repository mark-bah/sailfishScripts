require "net/http"
require "tmpdir"

# The email address to use for the Exchange User that will be associated with 
# all the catches and nets generated by this script.
DATA_GOV_USER_EMAIL_ADDRESS = "sailfish-data-gov@bah.com"

# A custom error class that will be thrown when a download fails.
class DownloadFailedError < RuntimeError ; end

#
# Provides a way to automatically consume every data set provided by data.gov.
#
# This script relies on access to the Rails environment and model files so it 
# should always be run by using `rails runner script/import_data_dot_gov.rb` from 
# the root directory of Exchange.
#
# See the documentation for `rails runner` for more information about specifying 
# options such as which Rails environment to use.
#
class DataDotGovImporter
  
  #
  # Creates a temporary directory in the OS standard location.  
  #
  # This directory will be re-used for the duration of each execution of this 
  # script, but will change each time the script is re-run  to ensure that the 
  # data is always fresh.
  #
  def download_directory
    unless defined? @_download_directory
      @_download_directory = Dir.mktmpdir("com.boozallen.sailfish.datadotgovimporter")
    end #unless
    @_download_directory
  end #download_directory
  
  #
  # Downloads the resource at the supplied `url` and saves it in the temporary 
  # directory for this particular execution of this script.
  #
  # If the download is successful, it will return the filesystem location of the 
  # file that was saved.
  #
  # If the download was not successful, it will raise a `DownloadFailedError` 
  # exception with the HTTP status code in the `message` property.
  #
  def download_resource(url)
    uri = URI(url)
    response = Net::HTTP.get(uri)
    
    # If the response was not successful, then raise an error.
    unless response.is_a? Net::HTTPSuccess
      raise DownloadFailedError, 
            "Download of url '#{url}' failed with status #{response.code} #{response.message}"
    end #unless
    
    # NOTE: It may be necessary to capture HTTP responses with a 3xx status code 
    # and automatically follow redirects.
    
    # Response was successful. Save the resource to the temp directory and return 
    # the filesystem path.
    path = File.join(self.download_directory, uri.path)
    File.open(path, "wb") do |file|
      file << response.body
    end #File.open
    path
  end #download_resource
  
  #
  # Main entry point for the script.
  #
  def self.main(args)
    # TODO: Download manifest of available data.gov resources, then iterate over 
    # each resource and create a Catch.  Sample code below:
    
    return # The code below is for sample purposes and should not be run.
    
    # SAMPLE CODE
    # Ensure we have a user to associate with all the catches and nets.
    
    user = User.where(email: DATA_GOV_USER_EMAIL_ADDRESS).first_or_create do |user|
      user.email        = DATA_GOV_USER_EMAIL_ADDRESS
      user.first_name   = "Data.gov"
      user.last_name    = ""
      user.about_me     = ""
    end #first_or_create

    manifest = JSON.load(File.read(self.download_resource("https://data.gov/manifest")))
    # I'm making assumptions here about what the structure of the manifest looks like.
    # You'll need to adjust these data sources as appropriate.
    manifest["sources"].each do |data_source| # data_source is assumed to be a URL
      begin
        # If we already have a catch for our user with this URL, skip this entry.
        next unless Catch.where(:user => user, :url => data_source).count.zero?
        # We don't already have this catch, create it.
        katch = Catch.new
        katch.url = data_source
        katch.image_url = "http://path/to/appropriate/image/if/applicable"
        katch.user = user
        katch.title = "Calculate an appropriate human-readable title for this catch"
        katch.description = "Determine an appropriate description for this catch."
        katch.keywords = [ "array", "of", "appropriate", "keywords" ]
        # This assumes that all catches will go in one Net.  It would be better to 
        # create a Net for each section of Data.gov data.  Update these lines 
        # as appropriate to select the correct Net.
        katch.gf_net = GfNet.where(:title => "Data.gov").first_or_create do |net|
          net.user = user
          net.title = "Data.gov"
          net.description = "A collection of data available through Data.gov"
        end #first_or_create
        katch.save! # Raise an exception if the record is not saved.
      rescue DownloadFailedError => e
        puts e.message
      rescue ActiveRecord::RecordInvalid => e
        # TODO: The catch did not save correctly. Print out an appropriate error
        # message for troubleshooting, then continue to the next data source.
      end #begin
    end #each
    
  rescue Exception => e
    puts "Encountered unhandled exception: #{e.message}"
    puts e.backtrace.join("\n")
    exit 1
  end #self.main
  
end #class DataDotGovImporter

# If this file is run directly rather than required from another file, then 
# run our `main` method.
DataDotGovImporter.main(ARGV) if $0 == __FILE__
